# EVE-NG/CML custom tool

Uses the [evengsdk](https://ttafsir.github.io/evengsdk/api_reference/#evengsdk.api.EvengApi.create_lab) and [virl2-client](https://github.com/CiscoDevNet/virl2-client) libraries to deploy labs from a minimalistic topology file with the device startup config generated by jinja templates

The topology file is split up into 4 parts, *input_file_example.yml* shows examples and explanations for the different device types

**lab:** The management details are lab-wise meaning that they will be used by all nodes in the lab.

```yaml
name: # The lab name, in EVE-NG this must be unique but CML doesn't matter (uses an arbitrary ID for uniqueness)
description: # Lab description
addr:
  mgmt_prefix: # Range all management address come from
  mgmt_gw: # Management range default gateway, used by all nodes
```

**nodes:** Dictionary of nodes to be created with the key being the node name and value the node details. *mgmt* defines the interface connected to management bridge and the management address (4th octet added to the *mgmt_prefix*). The interface (*intf*) details can be added now or later once know which links have been created, switches and firewalls have additional variables

```yaml
nodes:
  NODE_NAME:
    type: # Node type, in EVE-NG is known as the "template" and in CML the "node_definition"
    image: # (optional) Software version (defaults to newest), in EVE-NG known as "image", in CML "image_definition"
    eve_type: # (optional) Only used by EVE-NG, defaults to qemu so only need to define when using IOL
    ethernet: # (optional) Number of interfaces, if undefined uses the node type default (normally 4)
    config:
      template: # Per device_type jinja template used to create the config
      vars:
        hostname: # R1
        mgmt:
          MGMT_INTERFACE_NAME: # 4th octet of mgmt IP
        intf:
          INTERFACE_NAME: # x.x.x.x/yy
```

If you are going to use IOL nodes in EVE-NG you need to be aware of this [bug](https://github.com/ttafsir/evengsdk/issues/186) that breaks link assignment via the API. I submitted a [pull request](https://github.com/ttafsir/evengsdk/pull/220) to fix this but am not sure if the project is still maintained, as a workaround you will have to install this [branch](https://github.com/sjhloco/evengsdk/tree/fix_issue186_iol_interface_id) manually.

**networks:** Network objects provide local bridging (*bridge/unmanaged_switch*) as well as lab breakout (*pnet/external_connector*), this includes Internet access. The links for these network objects must be defined here under the object, they can not be defined under device links (*links*)

- For CML the type must start with *ec_* (an *external_connector*) and then be followed by whatever *bridge* or *virbr* numbers you have setup
- As only 1 device can be connected to a CML *external_connector*, setting the number of ports (*ethernet*) or specifying more than 1 connection (links) will automatically create an additonal *unmanaged_switch* (*ec_name_SWI*) and connect everything to that
- "*management: true*" indicates that all node management interfaces (set with *mgmt* variable) will be connected to this bridge

```yaml
networks:
  NETWORK_NAME:
    management: # When defined identifies this bridge is used for mgmt, all pre-defined node mgmt interfaces connect this
    type: # The network object type, EVE-NG can be "bridge" or "pnetX", CML can be "unmanaged_switch", "ec_bridgeX" or "ec_virbrX"
    links: # List of nodes that connect to this bridge. Uses the next available local and remote interface (for mgmt uses pre-defined remote interfaces) 
    ethernet: # Required for CML external_connectors if have more than 1 connection, automatically creates an unmanaged_switch (xx_SWI) to connect all devices
```

**links:** A dictionary of connections from *node_a* (key) to a list of *nodes_b* (value). Rather than having the verboseness of defining each connections interface you just define what is connected and the script will automatically assign the next available interface.

```yaml
links:
  NOOE_A: # Dict key is node_a and dict value is a list of all the devices it connects to
  R2: [R1, XNET-ASA]
```

Can set the lab server details at runtime, with environment variables or within the *lab_builder.py* file (in that order of preference).

```bash
export LAB_SERVER=x.x.x.x
export LAB_USERNAME=admin
export LAB_PASSWORD='pa$$w0rd'
export LAB_TEMPLATES=templates
```

As the tool is built on top off *click* you have the normal runtime *options* (filename, templates, host, username, password), *arguments* (EVE, CML) and *commands* (build, config, down, ls-nodes, up).

```bash
❯ python lab_builder.py --help
Usage: lab_builder.py [OPTIONS] [PLATFORM] COMMAND [ARGS]...

  Build a EVE or CML lab in a semi-declarative fashion based off a YAML topology file

Options:
  -f, --filename FILENAME  file.yaml or path/file.yaml topology defining the lab, defaults to script var (mylab.yml)
  -t, --templates PATH     Template directory, defaults to env-var -> script var (templates)
  -h, --host TEXT          EVE/CML server, defaults to env-var -> script var
  -u, --username TEXT      EVE/CML username, defaults to env-var -> script var
  -p, --password TEXT      EVE/CML password, defaults to env-var -> script var
  --help                   Show this message and exit.

Commands:
  build     Builds the lab based on the loaded topology file
  config    Regenerate and reapply the startup config to all devices
  down      Take DOWN all devices in the lab
  ls-nodes  Table displaying the details and status of all devices in lab
  up        Bring UP all devices in the lab
```

The first run of the script creates the lab, so adds all nodes and the defined links.

```bash
❯ python lab_builder.py -f cml_cisco_topo.yml CML build
or
❯ python lab_builder.py -f eve_cisco_topo.yml EVE build
✅ Creating lab:
- eve_cisco_topo_initial
✅ Creating devices:
- ISP
- R1
- R2
- XNET-ASA
- CORE-SWI
- WS01
- SVR01
✅ Creating network devices:
- MGMT
- INET
- XNET-SWI
✅ Creating links:
- ISP:Gi8 --> MGMT
- R1:e1/3 --> MGMT
- R2:e1/3 --> MGMT
- XNET-ASA:Mgmt0/0 --> MGMT
- CORE-SWI:e1/3 --> MGMT
- INET --> ISP:Gi1
- XNET-SWI --> R1:e0/0
- XNET-SWI --> R2:e0/0
- XNET-SWI --> XNET-ASA:Gi0/0
- ISP:Gi2 --> R1:e0/1
- ISP:Gi3 --> R2:e0/1
- CORE-SWI:e0/0 --> XNET-ASA:Gi0/1
- CORE-SWI:e0/1 --> WS01:e0
- CORE-SWI:e0/2 --> SVR01:e0
```

This will produce a randmised topology layout which you can then adjust in the GUI to be more human friendly.

<img width="1055" alt="Image" src="https://github.com/user-attachments/assets/650f89f2-07d8-4bd4-a474-2c91882e0d28" />

The *'build'* command also creates a new topology file (*xxx_v1.yml*) with an extra per-node *intf_links* dictionary that describes to whom each interface of the node connects to. It is worth noting this file also has a *lab_id* dictionary, this is what is used by all other runtime commands (*config, up, down, ls-nodes*) to know what lab to run the actions on.

```yaml {hl_lines=[11,12,13,14,25,26,27]}
nodes:
  ISP:
    type: csr1000vng
    ethernet: 8
    config:
      template: iosxel3_base.j2
      vars:
        hostname: R1
        mgmt:
          Gi8: 100
        intf_links:
          Gi1: L1 >> INET
          Gi2: L5 >> R1:e0/1
          Gi3: L6 >> R2:e0/1
  R1:
    type: iol
    eve_type: iol
    ethernet: 2
    config:
      template: iosxel3_base.j2
      vars:
        hostname: R1
        mgmt:
          e1/3: 101
        intf_links:
          e0/0: L2 >> XNET-SWI
          e0/1: L5 >> ISP:Gi2
.......
lab_id: /eve_cisco_topo_initial.unl
```

To assign the interface IP address for a router it should just be a case of changing the dictionary name to *intf* and adding the appropriate address to either end of the link, for switches and firewalls it is a bit more complicated as interfaces dont just have an IP address. 

```yaml {hl_lines=[11,12,13,14,25,26,27]}
nodes:
  ISP:
    type: csr1000vng
    ethernet: 8
    config:
      template: iosxel3_base.j2
      vars:
        hostname: R1
        mgmt:
          Gi8: 100
        intf:
          Gi1: dhcp
          Gi2: 10.1.40.1/30
          Gi3: 10.1.40.5/30
  R1:
    type: iol
    eve_type: iol
    ethernet: 2
    config:
      template: iosxel3_base.j2
      vars:
        hostname: R1
        mgmt:
          e1/3: 101
        intf:
          e0/0: 10.1.40.9/29
          e0/1: 10.1.40.2/30
```

Once the file has been changed you can regenerate the startup config and apply it to all devices using the *'config'* runtime command (it will first wipe all device configs).

```bash
❯ python lab_builder.py -f eve_cisco_topo_ip.yml EVE config
```

There are a few other commands to bringup or shutdown all nodes as well as produce a table to show the status of all the nodes.

```bash
❯ python lab_builder.py -f eve_cisco_topo_ip.yml EVE up
❯ python lab_builder.py -f eve_cisco_topo_ip.yml EVE down
❯ python lab_builder.py -f eve_cisco_topo_ip.yml EVE ls-nodes
                                                Nodes @ /eve_cisco_topo_initial.unl
┏━━━━┳━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━┳━━━━━━━━━━━━┳━━━━━━━━━━━━┳━━━━━━━━━┳━━━━━━┳━━━━━━┓
┃ Id ┃ Name     ┃ Url                         ┃ Image                            ┃ Template   ┃ Status     ┃ Console ┃ Ram  ┃ Cpu  ┃
┡━━━━╇━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━━╇━━━━━━━━━━━━╇━━━━━━━━━━━━╇━━━━━━━━━╇━━━━━━╇━━━━━━┩
│  1 │ ISP      │ telnet://10.40.10.120:32897 │ csr1000vng-universalk9.17.03.04a │ csr1000vng │ started 🟠 │ telnet  │ 4096 │ 1    │
│  2 │ R1       │ telnet://10.40.10.120:32898 │ L3-ADVENTERPRISEK9-M-17.15.1.bin │ iol        │ started 🟠 │ telnet  │ 1024 │ None │
│  3 │ R2       │ telnet://10.40.10.120:32899 │ L3-ADVENTERPRISEK9-M-17.15.1.bin │ iol        │ started 🟠 │ telnet  │ 1024 │ None │
│  4 │ XNET-ASA │ telnet://10.40.10.120:32900 │ asav-992                         │ asav       │ started 🟠 │ telnet  │ 2048 │ 1    │
│  5 │ CORE-SWI │ telnet://10.40.10.120:32901 │ L2-ADVENTERPRISEK9-M-17.15.1.bin │ iol        │ started 🟠 │ telnet  │ 1024 │ None │
│  6 │ WS01     │ telnet://10.40.10.120:32902 │ win-10                           │ win        │ started 🟠 │ telnet  │ 4096 │ 1    │
│  7 │ SVR01    │ telnet://10.40.10.120:32903 │ winserver-2012R2                 │ winserver  │ started 🟠 │ telnet  │ 8192 │ 1    │
└────┴──────────┴─────────────────────────────┴──────────────────────────────────┴────────────┴────────────┴─────────┴──────┴──────┘
```

### EVE-NG SDK commands

Some useful commands from trying to get the correct commands to work in iPython to then use in the script

Create the connection

```python
from evengsdk.client import EvengClient
host = "10.40.10.120"
username = "ste"
password = 'test123'

client = EvengClient(host, ssl_verify=False, protocol="http")
client.disable_insecure_warnings()  # disable warnings for self-signed certificates (only needed for https)
client.login(username=username, password=password)
```

Add a lab and get lab ID (path) for future commands

```python
lab = {"name": "lab", "description": "Test Lab", "path": "/"}
client.api.create_lab(**lab)
lab_path = f"{lab['path']}{lab['name']}.unl"
```

Add nodes and network objects

```python

node1 = {"name": "R1", "template": "vios", "left": 20, "top": 20, "ethernet": 8}
node2 = {"name": "R2", "template": "vios", "left": 120, "top": 120, "ethernet": 8}
node3 = {"name": "IOL1", "template": "iol", "node_type": "iol", "left": 220, "top": 220, "ethernet": 2}
node4 = {"name": "IOL1", "template": "iol", "node_type": "iol", "left": 320, "top": 320, "ethernet": 2}

client.api.add_node(lab_path, **node1)
client.api.add_node(lab_path, **node2)
client.api.add_node(lab_path, **node3)
client.api.add_node(lab_path, **node4)

net = dict(network_type='pnet1', visibility=1, name='CLD', left=58, top=57)
net1 = dict(network_type='bridge', visibility=1, name='BRI', left=58, top=57)
client.api.add_lab_network(lab_path, **net)
client.api.add_lab_network(lab_path, **net1)
```

Create links for networks and nodes

```python
net_link1 = {"src": "R1", "src_label": "Gi0/7", "dst": "CLD"}
net_link2 = {"src": "IOL1", "src_label": "e1/3", "dst": "CBRI"}
client.api.connect_node_to_cloud(lab_path, **net_link1)
client.api.connect_node_to_cloud(lab_path, **net_link2)

nd_link1 = {"src": "R1", "src_label": "Gi0/7", "dst": "R2", "dst_label": "Gi0/7"}
nd_link2 = {"src": "IOL3", "src_label": "e1/3", "dst": "IOL4", "dst_label": "e1/3"}
client.api.connect_node_to_node(lab_path, **nd_link1)
client.api.connect_node_to_node(lab_path, **nd_link1)

Show commands

```python
client.api.list_nodes(lab_path)
client.api.list_lab_networks(lab_path)
client.api.client.api.get_node_interfaces(lab_path, 1) # is node ID
client.api.get_lab_topology(lab_path)
```
